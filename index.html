<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/SymbolicUtils.jl/libs/highlight/github.min.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/franklin.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/tufte.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/custom.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/latex.css"> <link rel=stylesheet  href="/SymbolicUtils.jl/css/adjust.css"> <title>SymbolicUtils.jl — Symbolic programming in Julia</title> <h1><a href="/SymbolicUtils.jl/">SymbolicUtils.jl</a></h1> <div id=layout > <div id=menu > <ul> <li><a href="/SymbolicUtils.jl/">Manual</a> <li><a href="/SymbolicUtils.jl/interface/">Interfacing</a> <li><a href="/SymbolicUtils.jl/api/">API</a> </ul> </div> <div id=main > <div class=franklin-content ><h1 id=user_manual ><a href="#user_manual">User Manual</a></h1> <p><a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils</strong></a> is an practical symbolic programming utility written in Julia. It lets you <a href="#symbolic_expressions">create</a>, <a href="#rule-based_rewriting">rewrite</a> and <a href="#simplification">simplify</a> symbolic expressions.</p> <p>The main features are:</p> <ul> <li><p>Symbols &#40;<code>Sym</code>s&#41; carry type information. &#40;<a href="#symbolic_expressions">read more</a>&#41;</p> <li><p>Compound expressions composed of <code>Sym</code>s propagate type information. &#40;<a href="#symbolic_expressions">read more</a>&#41;</p> <li><p>A flexible <a href="#rule-based_rewriting">rule-based rewriting language</a> allowing liberal use of user defined matchers and rewriters.</p> <li><p>A <a href="#composing-rewriters">combinator library</a> for making rewriters.</p> <li><p>Set of <a href="#simplification">simplification rules</a>. These can be remixed and extended for special purposes.</p> </ul> <h2 id=table_of_contents ><a href="#table_of_contents">Table of contents</a></h2> <p><div class=franklin-toc ><ol><li><a href="#user_manual">User Manual</a><ol><li><a href="#table_of_contents">Table of contents</a><li><a href="#symbolic_expressions">Symbolic expressions</a><ol><li><a href="#simplified_printing">Simplified printing</a></ol><li><a href="#rule-based_rewriting">Rule-based rewriting</a><ol><li><a href="#predicates_for_matching">Predicates for matching</a><li><a href="#associative-commutative_rules">Associative-Commutative Rules</a></ol><li><a href="#composing_rewriters">Composing rewriters</a><li><a href="#simplification">Simplification</a><li><a href="#learn_more">Learn more</a></ol></ol></div> </p> <h2 id=symbolic_expressions ><a href="#symbolic_expressions">Symbolic expressions</a></h2> <p>First, let&#39;s use the <code>@syms</code> macro to create a few symbols.</p> <pre><code class=language-julia >using SymbolicUtils

@syms w z α::Real β::Real</code></pre> <div class=code-output ><pre><code class=plaintext >(w, z, α, β)</code></pre></div>
<p>Type annotations are optional when creating symbols. Here <code>α</code>, <code>β</code> behave like Real numbers. <code>w</code> and <code>z</code> behave like <code>Number</code>, which is the default. You can use the <code>symtype</code> function to find the type of a symbol.</p>
<pre><code class=language-julia >using SymbolicUtils: symtype

symtype&#40;w&#41;, symtype&#40;z&#41;,  symtype&#40;α&#41;, symtype&#40;β&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >(Number, Number, Real, Real)</code></pre></div>
<p>Note however that they are not subtypes of these types&#33;</p>
<pre><code class=language-julia >@show w isa Number
@show α isa Real</code></pre>
<div class=code-output ><pre><code class=plaintext >w isa Number = false
α isa Real = false
</code></pre></div>
<p>&#40;see <a href="https://discourse.julialang.org/t/ann-symbolicutils-jl-groundwork-for-a-symbolic-ecosystem-in-julia/38455/13?u&#61;shashi">this post</a> for why they are all not just subtypes of <code>Number</code>&#41;</p>
<p>You can do basic arithmetic on symbols to get symbolic expressions:</p>
<pre><code class=language-julia >expr1 &#61; α*sin&#40;w&#41;^2 &#43;  β*cos&#40;z&#41;^2
expr2 &#61; α*cos&#40;z&#41;^2 &#43;  β*sin&#40;w&#41;^2

expr1 &#43; expr2</code></pre>
<div class=code-output ><pre><code class=plaintext >((α * (sin(w) ^ 2)) + (β * (cos(z) ^ 2))) + ((α * (cos(z) ^ 2)) + (β * (sin(w) ^ 2)))</code></pre></div>
<h3 id=simplified_printing ><a href="#simplified_printing">Simplified printing</a></h3>
<p>Tip: you can set <code>SymbolicUtils.show_simplified&#91;&#93; &#61; true</code> to enable simplification on printing, or call <code>SymbolicUtils.showraw&#40;expr&#41;</code> to display an expression without simplification.  In the REPL, if an expression was successfully simplified before printing, it will appear in yellow rather than white, as a visual cue that what you are looking at is not the exact datastructure. </p>
<pre><code class=language-julia >using SymbolicUtils: showraw

showraw&#40;expr1 &#43; expr2&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >((α * (sin(w) ^ 2)) + (β * (cos(z) ^ 2))) + ((α * (cos(z) ^ 2)) + (β * (sin(w) ^ 2)))</code></pre></div>
<p><strong>Function-like symbols</strong></p>
<p>Symbols can be defined to behave like functions. Both the input and output types for the function can be specified. Any application to that function will only admit either values of those types or symbols of the same <code>symtype</code>.</p>
<pre><code class=language-julia >using SymbolicUtils
@syms f&#40;x&#41; g&#40;x::Real, y::Real&#41;::Real

f&#40;z&#41; &#43; g&#40;1, α&#41; &#43; sin&#40;w&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >(f(z) + g(1, α)) + sin(w)</code></pre></div>
<pre><code class=language-julia >g&#40;1, z&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >Argument to g(::Real, ::Real)::Real at position 2 must be of symbolic type Real
</code></pre></div>
<p>This does not work since <code>z</code> is a <code>Number</code>, not a <code>Real</code>.</p>
<pre><code class=language-julia >g&#40;2//5, g&#40;1, β&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >g(2//5, g(1, β))</code></pre></div>
<p>This works because <code>g</code> &quot;returns&quot; a <code>Real</code>.</p>
<h2 id=rule-based_rewriting ><a href="#rule-based_rewriting">Rule-based rewriting</a></h2>
<p>Rewrite rules match and transform an expression. A rule is written using either the <code>@rule</code> macro or the <code>@acrule</code> macro.</p>
<p>Here is a simple rewrite rule:</p>
<pre><code class=language-julia >r1 &#61; @rule ~x &#43; ~x &#61;&gt; 2 * &#40;~x&#41;

showraw&#40;r1&#40;sin&#40;1&#43;z&#41; &#43; sin&#40;1&#43;z&#41;&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >2 * sin(1 + z)</code></pre></div>
<p>The <code>@rule</code> macro takes a pair of patterns – the <em>matcher</em> and the <em>consequent</em> &#40;<code>@rule matcher &#61;&gt; consequent</code>&#41;. If an expression matches the matcher pattern, it is rewritten to the consequent pattern. <code>@rule</code> returns a callable object that applies the rule to an expression.</p>
<p><code>~x</code> in the example is what is a <strong>slot variable</strong> named <code>x</code>. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, all corresponding matches must be equal &#40;as tested by <code>Base.isequal</code> function&#41;. Hence this rule says: if you see something added to itself, make it twice of that thing, and works as such.</p>
<p>If you try to apply this rule to an expression where the two summands are not equal, it will return <code>nothing</code> – this is the way a rule signifies failure to match.</p>
<pre><code class=language-julia >r1&#40;sin&#40;1&#43;z&#41; &#43; sin&#40;1&#43;w&#41;&#41; &#61;&#61;&#61; nothing</code></pre>
<div class=code-output ><pre><code class=plaintext >true</code></pre></div>
<p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment variable</strong>. <code>~~xs</code> in the following example is a segment variable:</p>
<pre><code class=language-julia >@syms x y z
@rule&#40;&#43;&#40;~~xs&#41; &#61;&gt; ~~xs&#41;&#40;x &#43; y &#43; z&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >2-element view(::Array{SymbolicUtils.Symbolic{Number},1}, 1:2) with eltype SymbolicUtils.Symbolic{Number}:
 x + y
 z</code></pre></div>
<p><code>~~xs</code> is a vector of subexpressions matched. You can use it to construct something more useful:</p>
<pre><code class=language-julia >r2 &#61; @rule ~x * &#43;&#40;~~ys&#41; &#61;&gt; sum&#40;map&#40;y-&gt; ~x * y, ~~ys&#41;&#41;;

showraw&#40;r2&#40;2 * &#40;w&#43;w&#43;α&#43;β&#41;&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >(2 * ((w + w) + α)) + (2 * β)</code></pre></div>
<p>Notice that there is a subexpression <code>&#40;2 * w&#41; &#43; &#40;2 * w&#41;</code> that could be simplified by the previous rule <code>r1</code>. Can we chain <code>r2</code> and <code>r1</code>?</p>
<h3 id=predicates_for_matching ><a href="#predicates_for_matching">Predicates for matching</a></h3>
<p>Matcher pattern may contain slot variables with attached predicates, written as <code>~x::f</code> where <code>f</code> is a function that takes a matched expression &#40;a <code>Term</code> object a <code>Sym</code> or any Julia value that is in the expression tree&#41; and returns a boolean value. Such a slot will be considered a match only if <code>f</code> returns true.</p>
<p>Similarly <code>~~x::g</code> is a way of attaching a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurance should have a predicate.</p>
<p>For example,</p>
<pre><code class=language-julia >r &#61; @rule ~x &#43; ~~y::&#40;ys-&gt;iseven&#40;length&#40;ys&#41;&#41;&#41; &#61;&gt; &quot;odd terms&quot;

@show r&#40;w &#43; z &#43; z &#43; w&#41;
@show r&#40;w &#43; z &#43; z&#41;
@show r&#40;w &#43; z&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >r(w + z + z + w) = nothing
r(w + z + z) = nothing
r(w + z) = nothing
</code></pre></div>
<h3 id=associative-commutative_rules ><a href="#associative-commutative_rules">Associative-Commutative Rules</a></h3>
<p>Given an expression <code>f&#40;x, f&#40;y, z, u&#41;, v, w&#41;</code>, a <code>f</code> is said to be associative if the expression is equivalent to <code>f&#40;x, y, z, u, v, w&#41;</code> and commutative if the order of arguments does not matter.  SymbolicUtils has a special <code>@acrule</code> macro meant for rules on functions which are associate and commutative such as addition and multiplication of real and complex numbers.</p>
<pre><code class=language-julia >@syms x y

acr &#61; @acrule&#40;&#40;~y&#41;^&#40;~n&#41; * ~y &#61;&gt; &#40;~y&#41;^&#40;~n&#43;1&#41;&#41;

acr&#40;x^2 * y * x&#41;</code></pre>
<div class=code-output ></div>
<h2 id=composing_rewriters ><a href="#composing_rewriters">Composing rewriters</a></h2>
<p>A rewriter is any callable object which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.</p>
<p>The <code>SymbolicUtils.Rewriters</code> module contains some types which create and transform rewriters.</p>
<ul>
<li><p><code>Empty&#40;&#41;</code> is a rewriter which always returns <code>nothing</code></p>

<li><p><code>Chain&#40;itr&#41;</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</p>

<li><p><code>RestartedChain&#40;itr&#41;</code> like <code>Chain&#40;itr&#41;</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</p>

<li><p><code>IfElse&#40;cond, rw1, rw2&#41;</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it retuns false</p>

<li><p><code>If&#40;cond, rw&#41;</code> is the same as <code>IfElse&#40;cond, rw, Empty&#40;&#41;&#41;</code></p>

<li><p><code>Prewalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. <code>threaded&#61;true</code> will  use multi threading for traversal. <code>thread_cutoff</code> is the minimum number of nodes  in a subtree which should be walked in a threaded spawn.</p>

<li><p><code>Postwalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> similarly does post-order traversal.</p>

<li><p><code>Fixpoint&#40;rw&#41;</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</p>

<li><p><code>PassThrough&#40;rw&#41;</code> returns a rewriter which if <code>rw&#40;x&#41;</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw&#40;x&#41;</code>.</p>

</ul>
<p>Example using Postwalk, and Chain</p>
<pre><code class=language-julia >using SymbolicUtils
using SymbolicUtils.Rewriters

r1 &#61; @rule ~x &#43; ~x &#61;&gt; 2 * &#40;~x&#41;
r2 &#61; @rule ~x * &#43;&#40;~~ys&#41; &#61;&gt; sum&#40;map&#40;y-&gt; ~x * y, ~~ys&#41;&#41;;

rset &#61; Postwalk&#40;Chain&#40;&#91;r1, r2&#93;&#41;&#41;
rset_result &#61; rset&#40;2 * &#40;w&#43;w&#43;α&#43;β&#41;&#41;

showraw&#40;rset_result&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >(2 * ((2 * w) + α)) + (2 * β)</code></pre></div>
<p>It applied <code>r1</code>, but didn&#39;t get the opportunity to apply <code>r2</code>. So we need to apply the ruleset again on the result.</p>
<pre><code class=language-julia >showraw&#40;rset&#40;rset_result&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >((2 * (2 * w)) + (2 * α)) + (2 * β)</code></pre></div>
<p>You can also use <code>Fixpoint</code> to apply the rules until there are no changes.</p>
<pre><code class=language-julia >showraw&#40;Fixpoint&#40;rset&#41;&#40;2 * &#40;w&#43;w&#43;α&#43;β&#41;&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >((2 * (2 * w)) + (2 * α)) + (2 * β)</code></pre></div>
<h2 id=simplification ><a href="#simplification">Simplification</a></h2>
<p>The <code>simplify</code> function applies a built-in set of rules to rewrite expressions in order to simplify it.</p>
<pre><code class=language-julia >showraw&#40;simplify&#40;2 * &#40;w&#43;w&#43;α&#43;β &#43; sin&#40;z&#41;^2 &#43; cos&#40;z&#41;^2 - 1&#41;&#41;&#41;</code></pre>
<div class=code-output ><pre><code class=plaintext >2 * ((2 * w) + α + β)</code></pre></div>
<p>The rules in the default simplify applies simple constant elemination, trigonometric identities.</p>
<p>If you read the previous section on the rules DSL, you should be able to read and understand the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/simplify_rules.jl">rules</a> that are used by <code>simplify</code>.</p>
<h2 id=learn_more ><a href="#learn_more">Learn more</a></h2>
<p>If you have a package that you would like to utilize rule-based rewriting in, look at the suggestions in the <a href="/SymbolicUtils.jl/interface/">Interfacing</a> section to find out how you can do that without any fundamental changes to your package. Look at the <a href="/SymbolicUtils.jl/api/">API documentation</a> for docstrings about specific functions or macros.</p>
<p>Head over to the github repository to ask questions and <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">report problems</a>&#33; Join the <a href="https://julialang.zulipchat.com/#narrow/stream/236639-symbolic-programming">Zulip stream</a> to chat&#33;</p>
<div class=page-foot >
  <div class=copyright >
      &copy; Shashi Gowda, Yingbo Ma and Mason Protter. Last modified: December 21, 2020. <br> Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
        </div> 
    </div> 
    
    
        <script src="/SymbolicUtils.jl/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>