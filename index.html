<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/poole_hyde.css">
<link rel="stylesheet" href="/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/assets/favicon.png">

   <title>SymbolicUtils.jl — Symbolic programming in Julia</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/">SymbolicUtils<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item active" href="/">Getting Started</a>
      <a class="sidebar-nav-item " href="/representation/">Term representation</a>
      <a class="sidebar-nav-item " href="/rewrite/">Term Rewriting</a>
      <a class="sidebar-nav-item " href="/interface/">Interfacing</a>
      <a class="sidebar-nav-item " href="/codegen/">Code generation</a>
      <a class="sidebar-nav-item " href="/api/">API documentation</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content">
<h1>SymbolicUtils.jl &mdash; home</h1>


<p style="font-size: 1.25em; line-height: 1.67em; text-align: center; margin: 1em 0; color: #111;">
<a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils</a> is an practical symbolic programming utility in Julia. It lets you <a href="#symbolic_expressions">create</a>, <a href="#rule-based_rewriting">rewrite</a> and <a href="#simplification">simplify</a> symbolic expressions, and <a href="/codegen/">generate Julia code</a> from them.
</p>

<p><strong>Features:</strong></p>
<ul>
<li><p>Fast expressions</p>
</li>
<li><p>A <a href="/rewrite/#rule-based_rewriting">rule-based rewriting language</a>.</p>
</li>
<li><p>A <a href="/rewrite/#composing_rewriters">combinator library</a> for making rewriters.</p>
</li>
<li><p><a href="/representation/">Efficient representation</a> of numeric expressions</p>
</li>
<li><p>Type promotion:</p>
<ul>
<li><p>Symbols &#40;<code>Sym</code>s&#41; carry type information. &#40;<a href="#creating_symbolic_expressions">read more</a>&#41;</p>
</li>
<li><p>Compound expressions composed of <code>Sym</code>s propagate type information. &#40;<a href="#expression_interface">read more</a>&#41;</p>
</li>
</ul>
</li>
<li><p>Set of extendable <a href="#simplification">simplification rules</a>.</p>
</li>
</ul>

<br>
<h1>
 Getting Started
</h1>

<p><strong>Table of contents</strong></p>
<p><div class="franklin-toc"><ol><li><a href="#creating_symbolic_expressions">Creating symbolic expressions</a></li><li><a href="#expression_interface">Expression interface</a></li><li><a href="#term_rewriting">Term rewriting</a></li><li><a href="#simplification">Simplification</a></li><li><a href="#code_generation">Code generation</a></li><li><a href="#learn_more">Learn more</a></li></ol></div> </p>
<h2 id="creating_symbolic_expressions"><a href="#creating_symbolic_expressions" class="header-anchor">Creating symbolic expressions</a></h2>
<p>First, let&#39;s use the <code>@syms</code> macro to create a few symbols.</p>
<pre><code class="language-julia">using SymbolicUtils

@syms w z α::Real β::Real</code></pre><pre><code class="plaintext code-output">(w, z, α, β)</code></pre>
<p>Type annotations are optional when creating symbols. Here <code>α</code>, <code>β</code> behave like Real numbers. <code>w</code> and <code>z</code> behave like <code>Number</code>, which is the default. You can use the <code>symtype</code> function to find the type of a symbol.</p>
<pre><code class="language-julia">using SymbolicUtils: symtype

symtype&#40;w&#41;, symtype&#40;z&#41;,  symtype&#40;α&#41;, symtype&#40;β&#41;</code></pre><pre><code class="plaintext code-output">(Number, Number, Real, Real)</code></pre>
<p>Note however that they are not subtypes of these types&#33;</p>
<pre><code class="language-julia">@show w isa Number
@show α isa Real</code></pre><pre><code class="plaintext code-output">w isa Number = false
α isa Real = false
</code></pre>
<p>As their types are different:</p>
<pre><code class="language-julia">@show typeof&#40;w&#41;
@show typeof&#40;α&#41;</code></pre><pre><code class="plaintext code-output">typeof(w) = SymbolicUtils.Sym{Number, Nothing}
typeof(α) = SymbolicUtils.Sym{Real, Nothing}
</code></pre>
<p>&#40;see <a href="https://discourse.julialang.org/t/ann-symbolicutils-jl-groundwork-for-a-symbolic-ecosystem-in-julia/38455/13?u&#61;shashi">this post</a> for why they are all not just subtypes of <code>Number</code>&#41;</p>
<p>You can do basic arithmetic on symbols to get symbolic expressions:</p>
<pre><code class="language-julia">expr1 &#61; α*sin&#40;w&#41;^2 &#43; β*cos&#40;z&#41;^2
expr2 &#61; α*cos&#40;z&#41;^2 &#43; β*sin&#40;w&#41;^2

expr1 &#43; expr2</code></pre><pre><code class="plaintext code-output">α*(sin(w)^2) + α*(cos(z)^2) + β*(sin(w)^2) + β*(cos(z)^2)</code></pre>
<p>SymbolicUtils automatically simplifies</p>
<pre><code class="language-julia">2w &#43; 3w - 3z &#43; α</code></pre><pre><code class="plaintext code-output">α + 5w - 3z</code></pre>
<p>and reorders</p>
<pre><code class="language-julia">&#40;z &#43; w&#41;*&#40;α &#43; β&#41;</code></pre><pre><code class="plaintext code-output">(w + z)*(α + β)</code></pre>
<p>expressions of type <code>Symbolic&#123;&lt;:Number&#125;</code> &#40;which includes <code>Sym&#123;Real&#125;</code>&#41; when they are created. It also does constant elimination &#40;including rational numbers&#41;</p>
<pre><code class="language-julia">5 &#43; 2w - 3z &#43; α - &#40;β &#43; 5//3&#41; &#43; 3w - 2 &#43; 3//2 * β</code></pre><pre><code class="plaintext code-output">(4//3) + α + 5w + (1//2)*β - 3z</code></pre>
<p>It&#39;s worth remembering that the expression may be transformed with respect to the input when it&#39;s created.</p>
<p><strong>Function-like symbols</strong></p>
<p>Symbols can be defined to behave like functions. Both the input and output types for the function can be specified. Any application to that function will only admit either values of those types or symbols of the same <code>symtype</code>.</p>
<pre><code class="language-julia">using SymbolicUtils
@syms f&#40;x&#41; g&#40;x::Real, y::Real&#41;::Real

f&#40;z&#41; &#43; g&#40;1, α&#41; &#43; sin&#40;w&#41;</code></pre><pre><code class="plaintext code-output">sin(w) + f(z) + g(1, α)</code></pre>
<p>This does not work since <code>z</code> is a <code>Number</code>, not a <code>Real</code>.</p>
<pre><code class="language-julia">g&#40;1, z&#41;</code></pre><pre><code class="plaintext code-output">Tuple{Int64, Number} is not a subtype of Tuple{Real, Real}.
</code></pre>
<p>This works because <code>g</code> &quot;returns&quot; a <code>Real</code>.</p>
<pre><code class="language-julia">g&#40;2//5, g&#40;1, β&#41;&#41;</code></pre><pre><code class="plaintext code-output">g(2//5, g(1, β))</code></pre>
<h2 id="expression_interface"><a href="#expression_interface" class="header-anchor">Expression interface</a></h2>
<p>Symbolic expressions are of type <code>Term&#123;T&#125;</code>, <code>Add&#123;T&#125;</code>, <code>Mul&#123;T&#125;</code>, <code>Pow&#123;T&#125;</code> or <code>Div&#123;T&#125;</code> and denote some function call where one or more arguments are themselves such expressions or <code>Sym</code>s. See more about the representation <a href="/representation/">here</a>.</p>
<p>All the expression types support the following:</p>
<ul>
<li><p><code>istree&#40;x&#41;</code> – always returns <code>true</code> denoting, <code>x</code> is not a leaf node like Sym or a literal.</p>
</li>
<li><p><code>operation&#40;x&#41;</code> – the function being called</p>
</li>
<li><p><code>arguments&#40;x&#41;</code> – a vector of arguments</p>
</li>
<li><p><code>symtype&#40;x&#41;</code> – the &quot;inferred&quot; type &#40;<code>T</code>&#41;</p>
</li>
</ul>
<p>See more on the interface <a href="/interface">here</a></p>
<h2 id="term_rewriting"><a href="#term_rewriting" class="header-anchor">Term rewriting</a></h2>
<p>SymbolicUtils contains <a href="/rewrite/#rule-based_rewriting">a rule-based rewriting language</a> for easy pattern matching and rewriting of expression. There is also a <a href="/rewrite/#composing_rewriters">combinator library</a> to combine rules to chain, branch and loop over rules.</p>
<h2 id="simplification"><a href="#simplification" class="header-anchor">Simplification</a></h2>
<p>By default <code>&#43;</code>, <code>*</code> and <code>^</code> operations apply the most basic simplification upon construction of the expression.</p>
<p>The rules with which the canonical form of <code>Symbolic&#123;&lt;:Number&#125;</code> terms are constructed are the next &#40;where <code>x isa Symbolic</code> and <code>c isa Number</code>&#41;</p>
<ul>
<li><p><code>0 &#43; x</code>, <code>1 * x</code> and <code>x^1</code> always gives <code>x</code></p>
</li>
<li><p><code>0 * x</code> always gives <code>0</code> and <code>x ^ 0</code> gives <code>1</code></p>
</li>
<li><p><code>-x</code> becomes <code>&#40;-1&#41;*x</code></p>
</li>
<li><p>commutativity and associativity over <code>&#43;</code> and <code>*</code> are assumed. Re-ordering of terms will be done under a <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/ordering.jl">total order</a></p>
</li>
<li><p><code>p/q * x</code> or <code>x * p/q</code> results in <code>&#40;p*x&#41;/q</code></p>
</li>
<li><p><code>p/q * x/y</code> results in <code>&#40;p*x&#41;/&#40;q*y&#41;</code></p>
</li>
<li><p><code>x &#43; ... &#43; x</code> will be fused into <code>n*x</code> with type <code>Mul</code></p>
</li>
<li><p><code>x * ... * x</code> will be fused into <code>x^n</code> with type <code>Pow</code></p>
</li>
<li><p>sum of <code>Add</code>&#39;s are fused</p>
</li>
<li><p>product of <code>Mul</code>&#39;s are fused</p>
</li>
<li><p><code>c * &#40;c₁x₁ &#43; ... &#43; cₙxₙ&#41;</code> will be converted into <code>c*c₁*x₁ &#43; ... &#43; c*cₙ*xₙ</code></p>
</li>
<li><p><code>&#40;x₁^c₁ * ... * xₙ^cₙ&#41;^c</code> will be converted into <code>x₁^&#40;c*c₁&#41; * ... * xₙ^&#40;c*cₙ&#41;</code></p>
</li>
<li><p>there are come other simplifications on construction that you can check <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/methods.jl">here</a></p>
</li>
</ul>
<p>Here is an example of this</p>
<pre><code class="language-julia">2 * &#40;w&#43;w&#43;α&#43;β &#43; sin&#40;z&#41;^2 &#43; cos&#40;z&#41;^2 - 1&#41;</code></pre><pre><code class="plaintext code-output">4w + 2α + 2β + 2(cos(z)^2) + 2(sin(z)^2) - 2</code></pre>
<p>The <code>simplify</code> function applies a built-in set of rules to rewrite expressions in order to simplify it.</p>
<pre><code class="language-julia">simplify&#40;2 * &#40;w&#43;w&#43;α&#43;β &#43; sin&#40;z&#41;^2 &#43; cos&#40;z&#41;^2 - 1&#41;&#41;</code></pre><pre><code class="plaintext code-output">4w + 2α + 2β + 2(cos(z)^2) + 2(sin(z)^2) - 2</code></pre>
<p>The rules in the default simplify applies simple constant elimination and trigonometric identities.</p>
<p>If you read the previous section on the rules DSL, you should be able to read and understand the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/simplify_rules.jl">rules</a> that are used by <code>simplify</code>.</p>
<h2 id="code_generation"><a href="#code_generation" class="header-anchor">Code generation</a></h2>
<p><strong>Experimental feature</strong></p>
<p>It is common to want to generate executable code from symbolic expressions and blocks of them. We are working on experimental support for turning Symbolic expressions into executable functions with specific focus on array input and output and performance which is critical to the Differential Equations ecosystem which is making heavy use of this package.</p>
<p>See <a href="/codegen/">Code generation</a> for more about this.</p>
<h2 id="learn_more"><a href="#learn_more" class="header-anchor">Learn more</a></h2>
<p>If you have a package that you would like to utilize rule-based rewriting in, look at the suggestions in the <a href="/interface/">Interfacing</a> section to find out how you can do that without any fundamental changes to your package. Look at the <a href="/api/">API documentation</a> for docstrings about specific functions or macros.</p>
<p>Head over to the github repository to ask questions and <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">report problems</a>&#33; Join the <a href="https://julialang.zulipchat.com/#narrow/stream/236639-symbolic-programming">Zulip stream</a> to chat&#33;</p>
<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Yingbo Ma, Mason Protter. Last modified: September 10, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
