<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/poole_hyde.css">
<link rel="stylesheet" href="/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/assets/favicon.png">

   <title>SymbolicUtils.jl — Symbolic programming in Julia</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/">SymbolicUtils<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item active" href="/">Getting Started</a>
      <a class="sidebar-nav-item " href="/rewrite/">Term Rewriting</a>
      <a class="sidebar-nav-item " href="/interface/">Interfacing</a>
      <a class="sidebar-nav-item " href="/codegen/">Code generation</a>
      <a class="sidebar-nav-item " href="/api/">API documentation</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content">
<h1>SymbolicUtils.jl &mdash; home</h1>


<p style="font-size: 1.25em; line-height: 1.67em; text-align: center; margin: 1em 0; color: #111;">
<a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">SymbolicUtils</a> is an practical symbolic programming utility in Julia. It lets you <a href="#symbolic_expressions">create</a>, <a href="#rule-based_rewriting">rewrite</a> and <a href="#simplification">simplify</a> symbolic expressions, and <a href="/codegen/">generate Julia code</a> from them.
</p>

<p><strong>Features:</strong></p>
<ul>
<li><p>Fast expressions</p>
</li>
<li><p>A <a href="/rewrite/#rule-based_rewriting">rule-based rewriting language</a>.</p>
</li>
<li><p>A <a href="/rewrite/#composing_rewriters">combinator library</a> for making rewriters.</p>
</li>
<li><p>Type promotion:</p>
<ul>
<li><p>Symbols &#40;<code>Sym</code>s&#41; carry type information. &#40;<a href="#creating_symbolic_expressions">read more</a>&#41;</p>
</li>
<li><p>Compound expressions composed of <code>Sym</code>s propagate type information. &#40;<a href="#expression_interface">read more</a>&#41;</p>
</li>
</ul>
</li>
<li><p>Set of extendable <a href="#simplification">simplification rules</a>.</p>
</li>
</ul>

<br>
<h1>
 Getting Started
</h1>

<p><strong>Table of contents</strong></p>
<p><div class="franklin-toc"><ol><li><a href="#creating_symbolic_expressions">Creating symbolic expressions</a></li><li><a href="#expression_interface">Expression interface</a></li><li><a href="#term_rewriting">Term rewriting</a></li><li><a href="#simplification">Simplification</a></li><li><a href="#code_generation">Code generation</a></li><li><a href="#learn_more">Learn more</a></li></ol></div> </p>
<h2 id="creating_symbolic_expressions"><a href="#creating_symbolic_expressions" class="header-anchor">Creating symbolic expressions</a></h2>
<p>First, let&#39;s use the <code>@syms</code> macro to create a few symbols.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils

<span class="hljs-meta">@syms</span> w z α::<span class="hljs-built_in">Real</span> β::<span class="hljs-built_in">Real</span></code></pre><pre><code class="plaintext hljs">(w, z, α, β)</code></pre>
<p>Type annotations are optional when creating symbols. Here <code>α</code>, <code>β</code> behave like Real numbers. <code>w</code> and <code>z</code> behave like <code>Number</code>, which is the default. You can use the <code>symtype</code> function to find the type of a symbol.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils: symtype

symtype(w), symtype(z),  symtype(α), symtype(β)</code></pre><pre><code class="plaintext hljs">(Number, Number, Real, Real)</code></pre>
<p>Note however that they are not subtypes of these types&#33;</p>
<pre><code class="julia hljs"><span class="hljs-meta">@show</span> w <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Number</span>
<span class="hljs-meta">@show</span> α <span class="hljs-keyword">isa</span> <span class="hljs-built_in">Real</span></code></pre><pre><code class="plaintext hljs">w isa Number = false
α isa Real = false
</code></pre>
<p>As their types are different:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@show</span> typeof(w)
<span class="hljs-meta">@show</span> typeof(α)</code></pre><pre><code class="plaintext hljs">typeof(w) = SymbolicUtils.Sym{Number,Nothing}
typeof(α) = SymbolicUtils.Sym{Real,Nothing}
</code></pre>
<p>&#40;see <a href="https://discourse.julialang.org/t/ann-symbolicutils-jl-groundwork-for-a-symbolic-ecosystem-in-julia/38455/13?u&#61;shashi">this post</a> for why they are all not just subtypes of <code>Number</code>&#41;</p>
<p>You can do basic arithmetic on symbols to get symbolic expressions:</p>
<pre><code class="julia hljs">expr1 = α*sin(w)^<span class="hljs-number">2</span> + β*cos(z)^<span class="hljs-number">2</span>
expr2 = α*cos(z)^<span class="hljs-number">2</span> + β*sin(w)^<span class="hljs-number">2</span>

expr1 + expr2</code></pre><pre><code class="plaintext hljs">α*(sin(w)^2) + α*(cos(z)^2) + β*(sin(w)^2) + β*(cos(z)^2)</code></pre>
<p>SymbolicUtils automatically simplifies</p>
<pre><code class="julia hljs"><span class="hljs-number">2</span>w + <span class="hljs-number">3</span>w - <span class="hljs-number">3</span>z + α</code></pre><pre><code class="plaintext hljs">α + 5w - (3z)</code></pre>
<p>and reorders</p>
<pre><code class="julia hljs">(z + w)*(α + β)</code></pre><pre><code class="plaintext hljs">(w + z)*(α + β)</code></pre>
<p>expressions of type <code>Symbolic&#123;&lt;:Number&#125;</code> &#40;which includes <code>Sym&#123;Real&#125;</code>&#41; when they are created. It also does constant elimination &#40;including rational numbers&#41;</p>
<pre><code class="julia hljs"><span class="hljs-number">5</span> + <span class="hljs-number">2</span>w - <span class="hljs-number">3</span>z + α - (β + <span class="hljs-number">5</span>//<span class="hljs-number">3</span>) + <span class="hljs-number">3</span>w - <span class="hljs-number">2</span> + <span class="hljs-number">3</span>//<span class="hljs-number">2</span> * β</code></pre><pre><code class="plaintext hljs">(4//3) + α + 5w + (1//2)*β - (3z)</code></pre>
<p>It&#39;s worth remembering that the expression may be transformed with respect to the input when it&#39;s created.</p>
<p><strong>Function-like symbols</strong></p>
<p>Symbols can be defined to behave like functions. Both the input and output types for the function can be specified. Any application to that function will only admit either values of those types or symbols of the same <code>symtype</code>.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils
<span class="hljs-meta">@syms</span> f(x) g(x::<span class="hljs-built_in">Real</span>, y::<span class="hljs-built_in">Real</span>)::<span class="hljs-built_in">Real</span>

f(z) + g(<span class="hljs-number">1</span>, α) + sin(w)</code></pre><pre><code class="plaintext hljs">sin(w) + f(z) + g(1, α)</code></pre>
<p>This does not work since <code>z</code> is a <code>Number</code>, not a <code>Real</code>.</p>
<pre><code class="julia hljs">g(<span class="hljs-number">1</span>, z)</code></pre><pre><code class="plaintext hljs">Argument to g(::Real, ::Real)::Real at position 2 must be of symbolic type Real
</code></pre>
<p>This works because <code>g</code> &quot;returns&quot; a <code>Real</code>.</p>
<pre><code class="julia hljs">g(<span class="hljs-number">2</span>//<span class="hljs-number">5</span>, g(<span class="hljs-number">1</span>, β))</code></pre><pre><code class="plaintext hljs">g(2//5, g(1, β))</code></pre>
<h2 id="expression_interface"><a href="#expression_interface" class="header-anchor">Expression interface</a></h2>
<p>Symbolic expressions are of type <code>Term&#123;T&#125;</code>, <code>Add&#123;T&#125;</code>, <code>Mul&#123;T&#125;</code> or <code>Pow&#123;T&#125;</code> and denote some function call where one or more arguments are themselves such expressions or <code>Sym</code>s.</p>
<p>All the expression types support the following:</p>
<ul>
<li><p><code>istree&#40;x&#41;</code> – always returns <code>true</code> denoting, <code>x</code> is not a leaf node like Sym or a literal.</p>
</li>
<li><p><code>operation&#40;x&#41;</code> – the function being called</p>
</li>
<li><p><code>arguments&#40;x&#41;</code> – a vector of arguments</p>
</li>
<li><p><code>symtype&#40;x&#41;</code> – the &quot;inferred&quot; type &#40;<code>T</code>&#41;</p>
</li>
</ul>
<p>See more on the interface <a href="/interface">here</a></p>
<h2 id="term_rewriting"><a href="#term_rewriting" class="header-anchor">Term rewriting</a></h2>
<p>SymbolicUtils contains <a href="/rewrite/#rule-based_rewriting">a rule-based rewriting language</a> for easy pattern matching and rewriting of expression. There is also a <a href="/rewrite/#composing_rewriters">combinator library</a> to combine rules to chain, branch and loop over rules.</p>
<h2 id="simplification"><a href="#simplification" class="header-anchor">Simplification</a></h2>
<p>By default <code>*</code> and <code>&#43;</code> operations apply the most basic simplification upon construction of the expression.</p>
<p>Commutativity and associativity are assumed over <code>&#43;</code> and <code>*</code> operations on <code>Symbolic&#123;&lt;:Number&#125;</code>.</p>
<pre><code class="julia hljs"><span class="hljs-number">2</span> * (w+w+α+β + sin(z)^<span class="hljs-number">2</span> + cos(z)^<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β + 2(cos(z)^2) + 2(sin(z)^2) - 2</code></pre>
<p>The <code>simplify</code> function applies a built-in set of rules to rewrite expressions in order to simplify it.</p>
<pre><code class="julia hljs">simplify(<span class="hljs-number">2</span> * (w+w+α+β + sin(z)^<span class="hljs-number">2</span> + cos(z)^<span class="hljs-number">2</span> - <span class="hljs-number">1</span>))</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β + 2(cos(z)^2) + 2(sin(z)^2) - 2</code></pre>
<p>The rules in the default simplify applies simple constant elimination and trigonometric identities.</p>
<p>If you read the previous section on the rules DSL, you should be able to read and understand the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/src/simplify_rules.jl">rules</a> that are used by <code>simplify</code>.</p>
<h2 id="code_generation"><a href="#code_generation" class="header-anchor">Code generation</a></h2>
<p><strong>Experimental feature</strong></p>
<p>It is common to want to generate executable code from symbolic expressions and blocks of them. We are working on experimental support for turning Symbolic expressions into executable functions with specific focus on array input and output and performance which is critical to the Differential Equations ecosystem which is making heavy use of this package.</p>
<p>See <a href="/codegen/">Code generation</a> for more about this.</p>
<h2 id="learn_more"><a href="#learn_more" class="header-anchor">Learn more</a></h2>
<p>If you have a package that you would like to utilize rule-based rewriting in, look at the suggestions in the <a href="/interface/">Interfacing</a> section to find out how you can do that without any fundamental changes to your package. Look at the <a href="/api/">API documentation</a> for docstrings about specific functions or macros.</p>
<p>Head over to the github repository to ask questions and <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">report problems</a>&#33; Join the <a href="https://julialang.zulipchat.com/#narrow/stream/236639-symbolic-programming">Zulip stream</a> to chat&#33;</p>
<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Yingbo Ma, Mason Protter. Last modified: April 07, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        


    
  </body>
</html>
