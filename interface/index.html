<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/poole_hyde.css">
<link rel="stylesheet" href="/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/assets/favicon.png">

   <title>SymbolicUtils.jl — Interfacing</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/">SymbolicUtils<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/">Getting Started</a>
      <a class="sidebar-nav-item " href="/rewrite/">Term Rewriting</a>
      <a class="sidebar-nav-item active" href="/interface/">Interfacing</a>
      <a class="sidebar-nav-item " href="/codegen/">Code generation</a>
      <a class="sidebar-nav-item " href="/api/">API documentation</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="interfacing_with_symbolicutilsjl"><a href="#interfacing_with_symbolicutilsjl" class="header-anchor">Interfacing with SymbolicUtils.jl</a></h1>
<p><div class="franklin-toc"><ol><li><a href="#interfacing_with_symbolicutilsjl">Interfacing with SymbolicUtils.jl</a><ol><li><a href="#defining_the_interface">Defining the interface</a><ol><li><ol><li><a href="#istreext"><code>istree&#40;x::T&#41;</code></a></li><li><a href="#operationxt"><code>operation&#40;x::T&#41;</code></a></li><li><a href="#argumentsxt"><code>arguments&#40;x::T&#41;</code></a></li><li><a href="#similartermtmytype_f_args_t"><code>similarterm&#40;t::MyType, f, args&#91;, T&#93;&#41;</code></a></li></ol></li><li><a href="#optional">Optional</a><ol><li><a href="#symtypex"><code>symtype&#40;x&#41;</code></a></li><li><a href="#promote_symtypef_arg_symtypes"><code>promote_symtype&#40;f, arg_symtypes...&#41;</code></a></li></ol></li></ol></li><li><a href="#example">Example</a></li></ol></li></ol></div> </p>
<p>This section is for Julia package developers who may want to use the <code>simplify</code> and rule rewriting system on their own expression types.</p>
<h2 id="defining_the_interface"><a href="#defining_the_interface" class="header-anchor">Defining the interface</a></h2>
<p>SymbolicUtils matchers can match any Julia object that implements an interface to traverse it as a tree.</p>
<p>In particular, the following methods should be defined for an expression tree type <code>T</code> with symbol types <code>S</code> to  work with SymbolicUtils.jl</p>
<h4 id="istreext"><a href="#istreext" class="header-anchor"><code>istree&#40;x::T&#41;</code></a></h4>
<p>Check if <code>x</code> represents an expression tree. If returns true, it will be assumed that <code>operation&#40;::T&#41;</code> and <code>arguments&#40;::T&#41;</code> methods are defined. Definining these three should allow use of <code>simplify</code> on custom types. Optionally <code>symtype&#40;x&#41;</code> can be defined to return the expected type of the symbolic expression.</p>
<h4 id="operationxt"><a href="#operationxt" class="header-anchor"><code>operation&#40;x::T&#41;</code></a></h4>
<p>Returns the operation &#40;a function object&#41; performed by an expression tree. Called only if <code>istree&#40;::T&#41;</code> is true. Part of the API required for <code>simplify</code> to work. Other required methods are <code>arguments</code> and <code>istree</code></p>
<h4 id="argumentsxt"><a href="#argumentsxt" class="header-anchor"><code>arguments&#40;x::T&#41;</code></a></h4>
<p>Returns the arguments &#40;a <code>Vector</code>&#41; for an expression tree. Called only if <code>istree&#40;x&#41;</code> is <code>true</code>. Part of the API required for <code>simplify</code> to work. Other required methods are <code>operation</code> and <code>istree</code></p>
<p>In addition, the methods for <code>Base.hash</code> and <code>Base.isequal</code> should also be implemented by the types for the purposes of substitution and equality matching respectively.</p>
<h4 id="similartermtmytype_f_args_t"><a href="#similartermtmytype_f_args_t" class="header-anchor"><code>similarterm&#40;t::MyType, f, args&#91;, T&#93;&#41;</code></a></h4>
<p>Construct a new term with the operation <code>f</code> and arguments <code>args</code>, the term should be similar to <code>t</code> in type. if <code>t</code> is a <code>Term</code> object a new Term is created with the same symtype as <code>t</code>. If not, the result is computed as <code>f&#40;args...&#41;</code>. Defining this method for your term type will reduce any performance loss in performing <code>f&#40;args...&#41;</code> &#40;esp. the splatting, and redundant type computation&#41;. T is the symtype of the output term. You can use <code>promote_symtype</code> to infer this type.</p>
<p>The below two functions are internal to SymbolicUtils</p>
<h3 id="optional"><a href="#optional" class="header-anchor">Optional</a></h3>
<h4 id="symtypex"><a href="#symtypex" class="header-anchor"><code>symtype&#40;x&#41;</code></a></h4>
<p>The supposed type of values in the domain of x. Tracing tools can use this type to pick the right method to run or analyse code.</p>
<p>This defaults to <code>typeof&#40;x&#41;</code> if <code>x</code> is numeric, or <code>Any</code> otherwise. For the types defined in this package, namely <code>T&lt;:Symbolic&#123;S&#125;</code> it is <code>S</code>.</p>
<p>Define this for your symbolic types if you want <code>simplify</code> to apply rules specific to numbers &#40;such as commutativity of multiplication&#41;. Or such rules that may be implemented in the future.</p>
<h4 id="promote_symtypef_arg_symtypes"><a href="#promote_symtypef_arg_symtypes" class="header-anchor"><code>promote_symtype&#40;f, arg_symtypes...&#41;</code></a></h4>
<p>Returns the appropriate output type of applying <code>f</code> on arguments of type <code>arg_symtypes</code>.</p>
<h2 id="example"><a href="#example" class="header-anchor">Example</a></h2>
<p>Suppose you were feeling the temptations of type piracy and wanted to make a quick and dirty symbolic library built on top of Julia&#39;s <code>Expr</code> type, e.g.</p>
<pre><code class="julia hljs"><span class="hljs-keyword">for</span> f ∈ [:+, :-, :*, :/, :^] <span class="hljs-comment">#Note, this is type piracy!</span>
    <span class="hljs-meta">@eval</span> <span class="hljs-keyword">begin</span>
        Base.$f(x::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Expr</span>, <span class="hljs-built_in">Symbol</span>}, y::<span class="hljs-built_in">Number</span>) = <span class="hljs-built_in">Expr</span>(:call, $f, x, y)
        Base.$f(x::<span class="hljs-built_in">Number</span>, y::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Expr</span>, <span class="hljs-built_in">Symbol</span>}) = <span class="hljs-built_in">Expr</span>(:call, $f, x, y)
        Base.$f(x::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Expr</span>, <span class="hljs-built_in">Symbol</span>}, y::<span class="hljs-built_in">Union</span>{<span class="hljs-built_in">Expr</span>, <span class="hljs-built_in">Symbol</span>}) = (<span class="hljs-built_in">Expr</span>(:call, $f, x, y))
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>


ex = <span class="hljs-number">1</span> + (:x - <span class="hljs-number">2</span>)</code></pre><pre><code class="plaintext hljs">:((+)(1, (-)(x, 2)))</code></pre>
<p>How can we use SymbolicUtils.jl to convert <code>ex</code> to <code>&#40;-&#41;&#40;:x, 1&#41;</code>? We simply implement <code>istree</code>, <code>operation</code>, <code>arguments</code> and we&#39;ll be able to do rule-based rewriting on <code>Expr</code>s:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils

SymbolicUtils.istree(ex::<span class="hljs-built_in">Expr</span>) = ex.head == :call
SymbolicUtils.operation(ex::<span class="hljs-built_in">Expr</span>) = ex.args[<span class="hljs-number">1</span>]
SymbolicUtils.arguments(ex::<span class="hljs-built_in">Expr</span>) = ex.args[<span class="hljs-number">2</span>:<span class="hljs-keyword">end</span>]

<span class="hljs-meta">@rule</span>(~x =&gt; ~x - <span class="hljs-number">1</span>)(ex)</code></pre><pre><code class="plaintext hljs">Failed to precompile SymbolicUtils [d1185830-fcd6-423d-90d6-eec64667417b] to /home/runner/.julia/compiled/v1.5/SymbolicUtils/flNzo_EX7fh.ji.
</code></pre>
<p>However, this is not enough to get SymbolicUtils to use its own algebraic simplification system on <code>Expr</code>s:</p>
<pre><code class="julia hljs">simplify(ex)</code></pre><pre><code class="plaintext hljs">UndefVarError: simplify not defined
</code></pre>
<p>The reason that the expression was not simplified is that the expression tree is untyped, so SymbolicUtils  doesn&#39;t know what rules to apply to the expression. To mimic the behaviour of most computer algebra  systems, the simplest thing to do would be to assume that all <code>Expr</code>s are of type <code>Number</code>:</p>
<pre><code class="julia hljs">SymbolicUtils.symtype(s::<span class="hljs-built_in">Expr</span>) = <span class="hljs-built_in">Number</span>

simplify(ex)</code></pre><pre><code class="plaintext hljs">UndefVarError: SymbolicUtils not defined
</code></pre>
<p>Now SymbolicUtils is able to apply the <code>Number</code> simplification rule to <code>Expr</code>.</p>
<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Yingbo Ma, Mason Protter. Last modified: April 01, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and <a href="https://github.com/tlienart/PkgPage.jl">PkgPage.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        


    
  </body>
</html>
