<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/SymbolicUtils.jl/libs/highlight/github.min.css">
   
  <link rel="stylesheet" href="/SymbolicUtils.jl/css/franklin.css">
<link rel="stylesheet" href="/SymbolicUtils.jl/css/poole_hyde.css">
<link rel="stylesheet" href="/SymbolicUtils.jl/css/custom.css">
<!-- style adjustments -->
<style>
  html {font-size: 17px;}
  .franklin-content {position: relative; padding-left: 8%; padding-right: 5%;}
  @media (min-width: 940px) {
    .franklin-content {width: 100%; margin-left: auto; margin-right: auto;}
  }
  @media (max-width: 768px) {
    .franklin-content {padding-left: 6%; padding-right: 6%;}
  }
</style>
<link rel="icon" href="/SymbolicUtils.jl/assets/favicon.png">

   <title>SymbolicUtils.jl</title>  
</head>
<body>
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1 class="sidebar-title"><a href="/SymbolicUtils.jl/">SymbolicUtils<span style="opacity:0.4">.jl</span></a></h1>
      <br>
    </div>
    <style>
@media (min-width: 768px) {
    .sidebar-nav {
    }
}
    .sidebar .container.sidebar-sticky {
        top: 4rem;
    }
    .sidebar-nav .sidebar-nav-item.active {
        box-sizing: border-box;
        border-bottom: 1px #f1f1f1 solid;
        margin-right: -1em;
        margin-left: -0.5em;
        padding-left: 0.5em;
        color: white;
        font-weight: normal !important;
    }
    .sidebar-nav .sidebar-nav-item {
        color: #cccccc;
        margin: 0.25em 0;
    }
    </style>
    <nav class="sidebar-nav" style="opacity: 0.9">
      <a class="sidebar-nav-item " href="/SymbolicUtils.jl/">Getting Started</a>
      <a class="sidebar-nav-item active" href="/SymbolicUtils.jl/rewrite/">Term Rewriting</a>
      <a class="sidebar-nav-item " href="/SymbolicUtils.jl/interface/">Interfacing</a>
      <a class="sidebar-nav-item " href="/SymbolicUtils.jl/codegen/">Code generation</a>
      <a class="sidebar-nav-item " href="/SymbolicUtils.jl/api/">API documentation</a>
    </nav>

  </div>
  <div style="font-size: 0.85em; bottom: 3em; position: fixed">
      <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl">Go to GitHub repository &rarr;</a> <br>  <br>

      <a href="https://julialang.org/"><img src="https://raw.githubusercontent.com/JuliaLang/julia-logo-graphics/master/images/julia-logo-dark.svg" height="32" style="display: inline-block; margin-bottom: -8px; opacity: 0.7">
          powered.</a>
  </div>
</div>
<div class="content container">

<!-- Content appended here -->
<div class="franklin-content"><h1 id="term_rewriting"><a href="#term_rewriting">Term Rewriting</a></h1>
<h2 id="rule-based_rewriting"><a href="#rule-based_rewriting">Rule-based rewriting</a></h2>
<p>Rewrite rules match and transform an expression. A rule is written using either the <code>@rule</code> macro or the <code>@acrule</code> macro.</p>
<p>Here is a simple rewrite rule:</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils

<span class="hljs-meta">@syms</span> w z α::<span class="hljs-built_in">Real</span> β::<span class="hljs-built_in">Real</span>


r1 = <span class="hljs-meta">@rule</span> ~x + ~x =&gt; <span class="hljs-number">2</span> * (~x)

r1(sin(<span class="hljs-number">1</span>+z) + sin(<span class="hljs-number">1</span>+z))</code></pre>
<p>The <code>@rule</code> macro takes a pair of patterns – the <em>matcher</em> and the <em>consequent</em> &#40;<code>@rule matcher &#61;&gt; consequent</code>&#41;. If an expression matches the matcher pattern, it is rewritten to the consequent pattern. <code>@rule</code> returns a callable object that applies the rule to an expression.</p>
<p><code>~x</code> in the example is what is a <strong>slot variable</strong> named <code>x</code>. In a matcher pattern, slot variables are placeholders that match exactly one expression. When used on the consequent side, they stand in for the matched expression. If a slot variable appears twice in a matcher pattern, all corresponding matches must be equal &#40;as tested by <code>Base.isequal</code> function&#41;. Hence this rule says: if you see something added to itself, make it twice of that thing, and works as such.</p>
<p>If you try to apply this rule to an expression where the two summands are not equal, it will return <code>nothing</code> – this is the way a rule signifies failure to match.</p>
<pre><code class="julia hljs">r1(sin(<span class="hljs-number">1</span>+z) + sin(<span class="hljs-number">1</span>+w)) === <span class="hljs-literal">nothing</span></code></pre><pre><code class="plaintext hljs">true</code></pre>
<p>If you want to match a variable number of subexpressions at once, you will need a <strong>segment variable</strong>. <code>~~xs</code> in the following example is a segment variable:</p>
<pre><code class="julia hljs"><span class="hljs-meta">@syms</span> x y z
<span class="hljs-meta">@rule</span>(+(~~xs) =&gt; ~~xs)(x + y + z)</code></pre><pre><code class="plaintext hljs">3-element view(::Array{SymbolicUtils.Sym{Number},1}, 1:3) with eltype SymbolicUtils.Sym{Number}:
 x
 y
 z</code></pre>
<p><code>~~xs</code> is a vector of subexpressions matched. You can use it to construct something more useful:</p>
<pre><code class="julia hljs">r2 = <span class="hljs-meta">@rule</span> ~x * +(~~ys) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

r2(<span class="hljs-number">2</span> * (w+w+α+β))</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β</code></pre>
<p>Notice that there is a subexpression <code>&#40;2 * w&#41; &#43; &#40;2 * w&#41;</code> that could be simplified by the previous rule <code>r1</code>. Can we chain <code>r2</code> and <code>r1</code>?</p>
<h3 id="predicates_for_matching"><a href="#predicates_for_matching">Predicates for matching</a></h3>
<p>Matcher pattern may contain slot variables with attached predicates, written as <code>~x::f</code> where <code>f</code> is a function that takes a matched expression and returns a boolean value. Such a slot will be considered a match only if <code>f</code> returns true.</p>
<p>Similarly <code>~~x::g</code> is a way of attaching a predicate <code>g</code> to a segment variable. In the case of segment variables <code>g</code> gets a vector of 0 or more expressions and must return a boolean value. If the same slot or segment variable appears twice in the matcher pattern, then at most one of the occurance should have a predicate.</p>
<p>For example,</p>
<pre><code class="julia hljs">r = <span class="hljs-meta">@rule</span> ~x + ~~y::(ys-&gt;iseven(length(ys))) =&gt; <span class="hljs-string">&quot;odd terms&quot;</span>

<span class="hljs-meta">@show</span> r(w + z + z + w)
<span class="hljs-meta">@show</span> r(w + z + z)
<span class="hljs-meta">@show</span> r(w + z)</code></pre><pre><code class="plaintext hljs">r(w + z + z + w) = nothing
r(w + z + z) = nothing
r(w + z) = nothing
</code></pre>
<h3 id="associative-commutative_rules"><a href="#associative-commutative_rules">Associative-Commutative Rules</a></h3>
<p>Given an expression <code>f&#40;x, f&#40;y, z, u&#41;, v, w&#41;</code>, a <code>f</code> is said to be associative if the expression is equivalent to <code>f&#40;x, y, z, u, v, w&#41;</code> and commutative if the order of arguments does not matter.  SymbolicUtils has a special <code>@acrule</code> macro meant for rules on functions which are associate and commutative such as addition and multiplication of real and complex numbers.</p>
<pre><code class="julia hljs"><span class="hljs-meta">@syms</span> x y

acr = <span class="hljs-meta">@acrule</span>((~y)^(~n) * ~y =&gt; (~y)^(~n+<span class="hljs-number">1</span>))

acr(x^<span class="hljs-number">2</span> * y * x)</code></pre>
<h2 id="composing_rewriters"><a href="#composing_rewriters">Composing rewriters</a></h2>
<p>A rewriter is any callable object which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression. The Rules we created above are rewriters.</p>
<p>The <code>SymbolicUtils.Rewriters</code> module contains some types which create and transform rewriters.</p>
<ul>
<li><p><code>Empty&#40;&#41;</code> is a rewriter which always returns <code>nothing</code></p>
</li>
<li><p><code>Chain&#40;itr&#41;</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</p>
</li>
<li><p><code>RestartedChain&#40;itr&#41;</code> like <code>Chain&#40;itr&#41;</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</p>
</li>
<li><p><code>IfElse&#40;cond, rw1, rw2&#41;</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it retuns false</p>
</li>
<li><p><code>If&#40;cond, rw&#41;</code> is the same as <code>IfElse&#40;cond, rw, Empty&#40;&#41;&#41;</code></p>
</li>
<li><p><code>Prewalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. <code>threaded&#61;true</code> will  use multi threading for traversal. <code>thread_cutoff</code> is the minimum number of nodes  in a subtree which should be walked in a threaded spawn.</p>
</li>
<li><p><code>Postwalk&#40;rw; threaded&#61;false, thread_cutoff&#61;100&#41;</code> similarly does post-order traversal.</p>
</li>
<li><p><code>Fixpoint&#40;rw&#41;</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</p>
</li>
<li><p><code>PassThrough&#40;rw&#41;</code> returns a rewriter which if <code>rw&#40;x&#41;</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw&#40;x&#41;</code>.</p>
</li>
</ul>
<p>Example using Postwalk, and Chain</p>
<pre><code class="julia hljs"><span class="hljs-keyword">using</span> SymbolicUtils
<span class="hljs-keyword">using</span> SymbolicUtils.Rewriters

r1 = <span class="hljs-meta">@rule</span> ~x + ~x =&gt; <span class="hljs-number">2</span> * (~x)
r2 = <span class="hljs-meta">@rule</span> ~x * +(~~ys) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

rset = Postwalk(Chain([r1, r2]))
rset_result = rset(<span class="hljs-number">2</span> * (w+w+α+β))

rset_result</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β</code></pre>
<p>It applied <code>r1</code>, but didn&#39;t get the opportunity to apply <code>r2</code>. So we need to apply the ruleset again on the result.</p>
<pre><code class="julia hljs">rset(rset_result)</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β</code></pre>
<p>You can also use <code>Fixpoint</code> to apply the rules until there are no changes.</p>
<pre><code class="julia hljs">Fixpoint(rset)(<span class="hljs-number">2</span> * (w+w+α+β))</code></pre><pre><code class="plaintext hljs">4w + 2α + 2β</code></pre>
<div class="page-foot">
  <div class="copyright">
    &copy; Shashi Gowda, Yingbo Ma, Mason Protter. Last modified: January 30, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    </div>  <!-- div: content container -->
    
    <script>
        var els =  document.querySelectorAll(".language-julia")
        for (var i=0, l = els.length; i < l; i++) {
            var el = els[i]
            var out = el.parentNode.nextSibling
            if (out.tagName === "PRE") {
                out.className = out.className + " code-output"
            }
        }
    </script>
    
        


    
  </body>
</html>
