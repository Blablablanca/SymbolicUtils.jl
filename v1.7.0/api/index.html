<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SymbolicUtils.jl</title><meta name="title" content="API Reference · SymbolicUtils.jl"/><meta property="og:title" content="API Reference · SymbolicUtils.jl"/><meta property="twitter:title" content="API Reference · SymbolicUtils.jl"/><meta name="description" content="Documentation for SymbolicUtils.jl."/><meta property="og:description" content="Documentation for SymbolicUtils.jl."/><meta property="twitter:description" content="Documentation for SymbolicUtils.jl."/><meta property="og:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><meta property="twitter:url" content="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><link rel="canonical" href="https://docs.sciml.ai/SymbolicUtils/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymbolicUtils.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SymbolicUtils.jl — Symbolic programming in Julia</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/representation/">Term representation and simplification</a></li><li><a class="tocitem" href="../manual/rewrite/">Term Rewriting</a></li><li><a class="tocitem" href="../manual/interface/">Interfacing with SymbolicUtils.jl</a></li><li><a class="tocitem" href="../manual/codegen/">Code generation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Symbols-and-Terms"><span>Symbols and Terms</span></a></li><li><a class="tocitem" href="#Interfacing"><span>Interfacing</span></a></li><li><a class="tocitem" href="#Rewriters"><span>Rewriters</span></a></li><li><a class="tocitem" href="#Simplify"><span>Simplify</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../upgrade/">Upgrade to SymbolicUtils v1</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Symbols-and-Terms"><a class="docs-heading-anchor" href="#Symbols-and-Terms">Symbols and Terms</a><a id="Symbols-and-Terms-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols-and-Terms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@syms" href="#SymbolicUtils.@syms"><code>SymbolicUtils.@syms</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@syms &lt;lhs_expr&gt;[::T1] &lt;lhs_expr&gt;[::T2]...</code></pre><p>For instance:</p><pre><code class="nohighlight hljs">@syms foo::Real bar baz(x, y::Real)::Complex</code></pre><p>Create one or more variables. <code>&lt;lhs_expr&gt;</code> can be just a symbol in which case it will be the name of the variable, or a function call in which case a function-like variable which has the same name as the function being called. The Sym type, or in the case of a function-like Sym, the output type of calling the function can be set using the <code>::T</code> syntax.</p><p><strong>Examples:</strong></p><ul><li><code>@syms foo bar::Real baz::Int</code> will create</li></ul><p>variable <code>foo</code> of symtype <code>Number</code> (the default), <code>bar</code> of symtype <code>Real</code> and <code>baz</code> of symtype <code>Int</code></p><ul><li><code>@syms f(x) g(y::Real, x)::Int h(a::Int, f(b))</code> creates 1-arg <code>f</code> 2-arg <code>g</code></li></ul><p>and 2 arg <code>h</code>. The second argument to <code>h</code> must be a one argument function-like variable. So, <code>h(1, g)</code> will fail and <code>h(1, f)</code> will work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/types.jl#L928-L949">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.Sym</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.symtype" href="#SymbolicUtils.symtype"><code>SymbolicUtils.symtype</code></a> — <span class="docstring-category">Function</span></header><section><div><p>symtype(x)</p><p>Returns the symbolic type of <code>x</code>. By default this is just <code>typeof(x)</code>. Define this for your symbolic types if you want <code>SymbolicUtils.simplify</code> to apply rules specific to numbers (such as commutativity of multiplication). Or such rules that may be implemented in the future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/interface.jl#L9-L16">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.Term</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.Add</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.Mul</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>SymbolicUtils.Pow</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.promote_symtype" href="#SymbolicUtils.promote_symtype"><code>SymbolicUtils.promote_symtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">promote_symtype(f, Ts...)</code></pre><p>The result of applying <code>f</code> to arguments of <a href="#symtype"><code>symtype</code></a> <code>Ts...</code></p><pre><code class="language-julia hljs">julia&gt; promote_symtype(+, Real, Real)
Real

julia&gt; promote_symtype(+, Complex, Real)
Number

julia&gt; @syms f(x)::Complex
(f(::Number)::Complex,)

julia&gt; promote_symtype(f, Number)
Complex</code></pre><p>When constructing <a href="#Term"><code>Term</code></a>s without an explicit symtype, <code>promote_symtype</code> is used to figure out the symtype of the Term.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/types.jl#L837-L858">source</a></section><section><div><pre><code class="language-julia hljs">promote_symtype(f::FnType{X,Y}, arg_symtypes...)</code></pre><p>The output symtype of applying variable <code>f</code> to arguments of symtype <code>arg_symtypes...</code>. if the arguments are of the wrong type then this function will error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/types.jl#L875-L880">source</a></section></article><h2 id="Interfacing"><a class="docs-heading-anchor" href="#Interfacing">Interfacing</a><a id="Interfacing-1"></a><a class="docs-heading-anchor-permalink" href="#Interfacing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.istree" href="#SymbolicUtils.istree"><code>SymbolicUtils.istree</code></a> — <span class="docstring-category">Function</span></header><section><div><p>istree(x)</p><p>Returns <code>true</code> if <code>x</code> is a term. If true, <code>operation</code>, <code>arguments</code> must also be defined for <code>x</code> appropriately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/interface.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.operation" href="#SymbolicUtils.operation"><code>SymbolicUtils.operation</code></a> — <span class="docstring-category">Function</span></header><section><div><p>operation(x)</p><p>If <code>x</code> is a term as defined by <code>istree(x)</code>, <code>operation(x)</code> returns the head of the term if <code>x</code> represents a function call, for example, the head is the function being called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/interface.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.arguments" href="#SymbolicUtils.arguments"><code>SymbolicUtils.arguments</code></a> — <span class="docstring-category">Function</span></header><section><div><p>arguments(x)</p><p>Get the arguments of <code>x</code>, must be defined if <code>istree(x)</code> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/interface.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.similarterm" href="#SymbolicUtils.similarterm"><code>SymbolicUtils.similarterm</code></a> — <span class="docstring-category">Function</span></header><section><div><p>similarterm(x, head, args, symtype=nothing; metadata=nothing, exprhead=:call)</p><p>Returns a term that is in the same closure of types as <code>typeof(x)</code>, with <code>head</code> as the head and <code>args</code> as the arguments, <code>type</code> as the symtype and <code>metadata</code> as the metadata. By default this will execute <code>head(args...)</code>. <code>x</code> parameter can also be a <code>Type</code>. The <code>exprhead</code> keyword argument is useful  when manipulating <code>Expr</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/interface.jl#L73-L81">source</a></section></article><h2 id="Rewriters"><a class="docs-heading-anchor" href="#Rewriters">Rewriters</a><a id="Rewriters-1"></a><a class="docs-heading-anchor-permalink" href="#Rewriters" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@rule" href="#SymbolicUtils.@rule"><code>SymbolicUtils.@rule</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@rule LHS =&gt; RHS</code></pre><p>Creates a <code>Rule</code> object. A rule object is callable, and  takes an expression and rewrites it if it matches the LHS pattern to the RHS pattern, returns <code>nothing</code> otherwise. The rule language is described below.</p><p>LHS can be any possibly nested function call expression where any of the arguments can optionally be a Slot (<code>~x</code>) or a Segment (<code>~~x</code>) (described below).</p><p>If an expression matches LHS entirely, then it is rewritten to the pattern in the RHS Segment (<code>~x</code>) and slot variables (<code>~~x</code>) on the RHS will substitute the result of the matches found for these variables in the LHS.</p><p><strong>Slot</strong>:</p><p>A Slot variable is written as <code>~x</code> and matches a single expression. <code>x</code> is the name of the variable. If a slot appears more than once in an LHS expression then expression matched at every such location must be equal (as shown by <code>isequal</code>).</p><p><em>Example:</em></p><p>Simple rule to turn any <code>sin</code> into <code>cos</code>:</p><pre><code class="language-julia hljs">julia&gt; @syms a b c
(a, b, c)

julia&gt; r = @rule sin(~x) =&gt; cos(~x)
sin(~x) =&gt; cos(~x)

julia&gt; r(sin(1+a))
cos((1 + a))</code></pre><p>A rule with 2 segment variables</p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x + ~y) =&gt; sin(~x)*cos(~y) + cos(~x)*sin(~y)
sin(~x + ~y) =&gt; sin(~x) * cos(~y) + cos(~x) * sin(~y)

julia&gt; r(sin(a + b))
cos(a)*sin(b) + sin(a)*cos(b)</code></pre><p>A rule that matches two of the same expressions:</p><pre><code class="language-julia hljs">julia&gt; r = @rule sin(~x)^2 + cos(~x)^2 =&gt; 1
sin(~x) ^ 2 + cos(~x) ^ 2 =&gt; 1

julia&gt; r(sin(2a)^2 + cos(2a)^2)
1

julia&gt; r(sin(2a)^2 + cos(a)^2)
# nothing</code></pre><p><strong>Segment</strong>:</p><p>A Segment variable is written as <code>~~x</code> and matches zero or more expressions in the function call.</p><p><em>Example:</em></p><p>This implements the distributive property of multiplication: <code>+(~~ys)</code> matches expressions like <code>a + b</code>, <code>a+b+c</code> and so on. On the RHS <code>~~ys</code> presents as any old julia array.</p><pre><code class="language-julia hljs">julia&gt; r = @rule ~x * +((~~ys)) =&gt; sum(map(y-&gt; ~x * y, ~~ys));

julia&gt; r(2 * (a+b+c))
((2 * a) + (2 * b) + (2 * c))</code></pre><p><strong>Predicates</strong>:</p><p>There are two kinds of predicates, namely over slot variables and over the whole rule. For the former, predicates can be used on both <code>~x</code> and <code>~~x</code> by using the <code>~x::f</code> or <code>~~x::f</code>. Here <code>f</code> can be any julia function. In the case of a slot the function gets a single matched subexpression, in the case of segment, it gets an array of matched expressions.</p><p>The predicate should return <code>true</code> if the current match is acceptable, and <code>false</code> otherwise.</p><pre><code class="language-julia hljs">julia&gt; two_πs(x::Number) = abs(round(x/(2π)) - x/(2π)) &lt; 10^-9
two_πs (generic function with 1 method)

julia&gt; two_πs(x) = false
two_πs (generic function with 2 methods)

julia&gt; r = @rule sin(~~x + ~y::two_πs + ~~z) =&gt; sin(+(~~x..., ~~z...))
sin(~(~x) + ~(y::two_πs) + ~(~z)) =&gt; sin(+(~(~x)..., ~(~z)...))

julia&gt; r(sin(a+3π))

julia&gt; r(sin(a+6π))
sin(a)

julia&gt; r(sin(a+6π+c))
sin((a + c))</code></pre><p>Predicate function gets an array of values if attached to a segment variable (<code>~~x</code>).</p><p>For the predicate over the whole rule, use <code>@rule &lt;LHS&gt; =&gt; &lt;RHS&gt; where &lt;predicate&gt;</code>:</p><pre><code class="nohighlight hljs">julia&gt; @syms a b;

julia&gt; predicate(x) = x === a;

julia&gt; r = @rule ~x =&gt; ~x where f(~x);

julia&gt; r(a)
a

julia&gt; r(b) === nothing
true</code></pre><p>Note that this is syntactic sugar and that it is the same as something like <code>@rule ~x =&gt; f(~x) ? ~x : nothing</code>.</p><p><strong>Context</strong>:</p><p><em>In predicates</em>: Contextual predicates are functions wrapped in the <code>Contextual</code> type. The function is called with 2 arguments: the expression and a context object passed during a call to the Rule object (maybe done by passing a context to <code>simplify</code> or a <code>RuleSet</code> object).</p><p>The function can use the inputs however it wants, and must return a boolean indicating whether the predicate holds or not.</p><p><em>In the consequent pattern</em>: Use <code>(@ctx)</code> to access the context object on the right hand side of an expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/rule.jl#L165-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.Rewriters" href="#SymbolicUtils.Rewriters"><code>SymbolicUtils.Rewriters</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A rewriter is any function which takes an expression and returns an expression or <code>nothing</code>. If <code>nothing</code> is returned that means there was no changes applicable to the input expression.</p><p>The <code>Rewriters</code> module contains some types which create and transform rewriters.</p><ul><li><code>Empty()</code> is a rewriter which always returns <code>nothing</code></li><li><code>Chain(itr)</code> chain an iterator of rewriters into a single rewriter which applies  each chained rewriter in the given order.  If a rewriter returns <code>nothing</code> this is treated as a no-change.</li><li><code>RestartedChain(itr)</code> like <code>Chain(itr)</code> but restarts from the first rewriter once on the  first successful application of one of the chained rewriters.</li><li><code>IfElse(cond, rw1, rw2)</code> runs the <code>cond</code> function on the input, applies <code>rw1</code> if cond  returns true, <code>rw2</code> if it returns false</li><li><code>If(cond, rw)</code> is the same as <code>IfElse(cond, rw, Empty())</code></li><li><code>Prewalk(rw; threaded=false, thread_cutoff=100)</code> returns a rewriter which does a pre-order  traversal of a given expression and applies the rewriter <code>rw</code>. Note that if  <code>rw</code> returns <code>nothing</code> when a match is not found, then <code>Prewalk(rw)</code> will  also return nothing unless a match is found at every level of the walk.  <code>threaded=true</code> will use multi threading for traversal. <code>thread_cutoff</code> is  the minimum number of nodes in a subtree which should be walked in a  threaded spawn.</li><li><code>Postwalk(rw; threaded=false, thread_cutoff=100)</code> similarly does post-order traversal.</li><li><code>Fixpoint(rw)</code> returns a rewriter which applies <code>rw</code> repeatedly until there are no changes to be made.</li><li><code>FixpointNoCycle</code> behaves like <a href="@ref"><code>Fixpoint</code></a> but instead it applies <code>rw</code> repeatedly only while it is returning new results.</li><li><code>PassThrough(rw)</code> returns a rewriter which if <code>rw(x)</code> returns <code>nothing</code> will instead  return <code>x</code> otherwise will return <code>rw(x)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/rewriters.jl#L1-L31">source</a></section></article><h2 id="Simplify"><a class="docs-heading-anchor" href="#Simplify">Simplify</a><a id="Simplify-1"></a><a class="docs-heading-anchor-permalink" href="#Simplify" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.simplify" href="#SymbolicUtils.simplify"><code>SymbolicUtils.simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simplify(x; expand=false,
            threaded=false,
            thread_subtree_cutoff=100,
            rewriter=nothing)</code></pre><p>Simplify an expression (<code>x</code>) by applying <code>rewriter</code> until there are no changes. <code>expand=true</code> applies <a href="/api/#expand"><code>expand</code></a> in the beginning of each fixpoint iteration.</p><p>By default, simplify will assume denominators are not zero and allow cancellation in fractions. Pass <code>simplify_fractions=false</code> to prevent this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/simplify.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.expand" href="#SymbolicUtils.expand"><code>SymbolicUtils.expand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">expand(expr)</code></pre><p>Expand expressions by distributing multiplication over addition, e.g., <code>a*(b+c)</code> becomes <code>ab+ac</code>.</p><p><code>expand</code> uses replace symbols and non-algebraic expressions by variables of type <code>variable_type</code> to compute the distribution using a specialized sparse multivariate polynomials implementation. <code>variable_type</code> can be any subtype of <code>MultivariatePolynomials.AbstractVariable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/polyform.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.substitute" href="#SymbolicUtils.substitute"><code>SymbolicUtils.substitute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">substitute(expr, dict; fold=true)</code></pre><p>substitute any subexpression that matches a key in <code>dict</code> with the corresponding value. If <code>fold=false</code>, expressions which can be evaluated won&#39;t be evaluated.</p><pre><code class="language-julia hljs">julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=true)
2.414213562373095
julia&gt; substitute(1+sqrt(y), Dict(y =&gt; 2), fold=false)
1 + sqrt(2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/substitute.jl#L2-L15">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymbolicUtils.@timerewrite" href="#SymbolicUtils.@timerewrite"><code>SymbolicUtils.@timerewrite</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@timerewrite expr</code></pre><p>If <code>expr</code> calls <code>simplify</code> or a <code>RuleSet</code> object, track the amount of time it spent on applying each rule and pretty print the timing.</p><p>This uses <a href="https://github.com/KristofferC/TimerOutputs.jl">TimerOutputs.jl</a>.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">
julia&gt; expr = foldr(*, rand([a,b,c,d], 100))
(a ^ 26) * (b ^ 30) * (c ^ 16) * (d ^ 28)

julia&gt; @timerewrite simplify(expr)
 ────────────────────────────────────────────────────────────────────────────────────────────────
                                                         Time                   Allocations
                                                 ──────────────────────   ───────────────────────
                Tot / % measured:                     340ms / 15.3%           92.2MiB / 10.8%

 Section                                 ncalls     time   %tot     avg     alloc   %tot      avg
 ────────────────────────────────────────────────────────────────────────────────────────────────
 ACRule((~y) ^ ~n * ~y =&gt; (~y) ^ (~n ...    667   11.1ms  21.3%  16.7μs   2.66MiB  26.8%  4.08KiB
   RHS                                       92    277μs  0.53%  3.01μs   14.4KiB  0.14%     160B
 ACRule((~x) ^ ~n * (~x) ^ ~m =&gt; (~x)...    575   7.63ms  14.6%  13.3μs   1.83MiB  18.4%  3.26KiB
 (*)(~(~(x::!issortedₑ))) =&gt; sort_arg...    831   6.31ms  12.1%  7.59μs    738KiB  7.26%     910B
   RHS                                      164   3.03ms  5.81%  18.5μs    250KiB  2.46%  1.52KiB
   ...
   ...
 ────────────────────────────────────────────────────────────────────────────────────────────────
(a ^ 26) * (b ^ 30) * (c ^ 16) * (d ^ 28)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSymbolics/SymbolicUtils.jl/blob/38ec2bbfa473cc528d03ebe1d47b857a3a03e2a2/src/rule.jl#L446-L479">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/codegen/">« Code generation</a><a class="docs-footer-nextpage" href="../upgrade/">Upgrade to SymbolicUtils v1 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 16 May 2024 16:03">Thursday 16 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
